# 设计模式

_注：`设计模式`的笔记均来自李建忠的设计模式课程_

## 前言

**定义**：每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动

软件设计复杂的根本原因：**变化**

> 客户需求的变化  
> 技术平台的变化  
> 开发团队的变化  
> 市场环境的变化  
> ...

所以设计模式的目标是：管理变化，提高复用

如何解决复杂性：**分解** 和 **抽象**

> **分解**：人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题  
> **抽象**：更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型

## 设计原则

通常所说的“设计模式”隐含地表示“面向对象设计模式”，但并不意味着“设计模式”就等于“面向对象设计模式”  
变化是复用的天敌，面向对象设计最大的优势在于：抵御变化！

### 面向对象设计八大原则

- 依赖倒置原则（DIP）
  > 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）  
  > 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）
- 开放封闭原则（OCP）
  > 对扩展开放，对更改封闭  
  > 类模块应该是可扩展的，但是不可修改
- 单一职责原则（SRP）
  > 一个类应该仅有一个引起它变化的原因  
  > 变化的方向隐含着类的责任
- Liskov 替换原则（LSP）
  > 子类必须能够替换它们的基类（IS-A）  
  > 继承表达类型抽象
- 接口隔离原则（ISP）
  > 不应该强迫客户程序依赖它们不用的方法  
  > 接口应该小而完备
- 优先使用对象组合，而不是类继承
  > 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”  
  > 继承在某种程度上破坏了封装性，子类父类耦合度很高  
  > 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低
- 封装变化点
  > 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次的松耦合
- 针对接口编程，而不是针对实现编程
  > 不将变量类型声明为某个特定的具体类，而是声明为某个接口  
  > 客户程序无需获取对象的具体类型，只需要知道对象所具有的接口  
  > 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案

### 将设计原则提升为设计经验

- 设计习语 Design Idioms
  - Design Idioms 描述与特定编程语言相关的低层模式，技巧，惯用法
- 设计模式 Design Patterns
  - Design Patterns 主要描述的是“类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面
- 架构模式 Architectural Patterns
  - Architectural Patterns 描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则

## 设计模式分类

### 从目的来看

- 创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击
- 结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击
- 行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击

### 从范围上看

- 类模式处理类与子类的静态关系
- 对象模式处理对象之间的动态关系

### 从封装变化角度看

封装变化角度也是本课程要介绍的 23 种设计模式

- **组件协作** 模式：

  > 现代软件专业分工之后的一个结果就是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式
  - [模板方法 Template Method](./模式/1.模板方法.md)
  - [策略模式 Strategy](./模式/2.策略模式.md)
  - [观察者模式 Observer](./模式/3.观察者模式.md)
- **单一职责** 模式：

  > 在软件组件的设计中，如果责任划分得不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任
  - [装饰器模式 Decorator](./模式/4.装饰器模式.md)
  - [桥模式 Bridge](./模式/5.桥模式.md)
- **对象创建** 模式：

  > 通过“对象创建”模式绕开 new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作
  - [工厂方法 Factory Method](./模式/6.工厂方法.md)
  - [抽象工厂方法 Abstract Factory](./模式/7.抽象工厂方法.md)
  - [原型模式 Prototype](./模式/8.原型模式.md)
  - [构建器模式 Builder](./模式/9.构建器模式.md)
- **接口性能** 模式：

  > 面对对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理
  - [单件模式 Singleton](./模式/10.单件模式.md)
  - [享元模式 Flyweight](./模式/11.享元模式.md)
- **接口隔离** 模式：  

  > 在组件构建过程中，某些接口之间的直接依赖常常会带来很多问题，甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案
  - [门面模式 Facade](./模式/12.门面模式.md)
  - [代理模式 Proxy](./模式/13.代理模式.md)
  - [适配器模式 Adapter](./模式/14.适配器模式.md)
  - [中介者模式 Mediator](./模式/15.中介者模式.md)
- **状态变化** 模式：

  > 在组建构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案
  - [状态模式 State](./模式/16.状态模式.md)
  - [备忘录模式 Memento](./模式/17.备忘录模式.md)
- **数据结构** 模式：

  > 常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现特定数据结构无关的访问，是一种行之有效的解决方案
  - [组合模式 Composite](./模式/18.组合模式.md)
  - [迭代器模式 Iterator](./模式/19.迭代器模式.md)
  - [职责链模式 Chain of Resposibility](./模式/20.职责链模式.md)
- **行为变化** 模式：

  > 在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为模式”将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合
  - [命令模式 Command](./模式/21.命令模式.md)
  - [访问器模式 Visitor](./模式/22.访问器模式.md)
- **领域规则** 模式：

  > 在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出该领域下的一般性解决方案
  - [解析器模式 Interpreter](./模式/23.解析器模式.md)

## 重构获得模式

- 面向对象设计模式是“好的面向对象设计”，所谓“好的面向对象”设计指是那些可以满足“应对变化，提高复用”的设计
- 现代软件设计的特征是“需求的频繁变化”。设计模式的要点是“寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化”。“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更重要
- 设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的“Refactoring to Patterns”是目前普通公认的最好的使用设计模式的方法

## 重构关键技法

- 静态 -> 动态
- 早绑定 -> 晚绑定
- 继承 -> 组合
- 编译时依赖 -> 运行时依赖
- 紧耦合 -> 松耦合

## 总结

- 什么时候不用模式
  - 代码可读性很差时
  - 需求理解还很浅时
  - 变化没有显现时
  - 不是系统的关键依赖点
  - 项目没有复用价值时
  - 项目将要发布时
- 经验之谈
  - 不要为模式而模式
  - 关注抽象类 & 接口
  - 理清变化点和稳定点
  - 审视依赖关系
  - 要有 Framework 和 Application 的区隔思维
  - 良好的设计是演化的结果
- 设计模式成长之路
  - “手中有剑，心中无剑”：见模式而不知
  - “手中有剑，心中无剑”：可以识别模式，作为应用开发人员使用模式
  - “手中有剑，心中有剑”：作为框架开发人员为应用设计某些模式
  - “手中无剑，心中有剑”：忘掉模式，只有原则
