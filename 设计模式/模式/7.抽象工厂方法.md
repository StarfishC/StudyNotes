# 抽象工厂方法 Abstract Factory

## 动机

- 在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作
- 如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？

## 模式定义

提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类

<div align="center"><img src="./images/抽象工厂.png" alt="抽象工厂" height= width= /></div>

## 例子

原始需求：一个sqlserver的连接、操作和读取

```cpp
class EmployeeDAO
{
public:
    vector<EmployeeDO> GetEmployees()
    {
        SqlConnection* connection = new SqlConnection();
        connection->ConnectionString = "...";

        SqlCommand* command = new SqlCommand();
        command->CommmandText = "...";

        SqlDataReader* reader = command->ExecuteReader();
        while(reader->Read()) { }
    }
}
```

需求2：需要支持多种数据库的动作。那么需要面向对象接口编程，建立一个数据库访问的基类

```cpp
// 数据库访问有关的纯虚基类
class IDBConnection {}
class IDBCommand {}
class IDataReader {}

// 具体类
// sqlserver
class SqlConnection : public IDBConnection {}
class SqlCommand : public IDBCommand {}
class SqlDataReader : public IDataReader {}
// 支持Oracle
class OracleConnection : public IDBConnection {}
class OracleCommand : public IDBCommand {}
class OracleDataReader : public IDataReader {}

// 使用
class EmployeeDAO
{
public:
    vector<EmployeeDO> GetEmployees()
    {
        IDBConnection* connection = new SqlConnection();
        connection->ConnectionString = "...";

        IDBCommand* command = new SqlCommand();
        command->CommmandText = "...";

        IDataReader* reader = command->ExecuteReader();
        while(reader->Read()) { }
    }
}

// 可以看出上述代码的new出对象的问题没有得到解决，那么可以使用工厂方法来进行改善
// 同样需要三个工厂纯虚基类
class IDBConnectionFactory
{
public:
    virtual IDBConnection* CreateDBConnection() = 0;
};
class IDBCommandFactory
{
public:
    virtual IDBCommand* CreateDBCommand() = 0;
};
class IDataReaderFactory
{
public:
    virtual IDataReader* CreateDataReader() = 0;
};

// 具体工厂对象
// sqlserver
class SqlConnectionFactory : public IDBConnectionFactory {}
class SqlCommandFactory : public IDBCommandFactory {}
class SqlDataReader : public IDataReaderFactory {}
// Oracle
class OracleConnectionFactory : public IDBConnectionFactory {}
class OracleCommandFactory : public IDBCommandFactory {}
class OracleDataReader : public IDataReaderFactory {}

// 那么使用方式变成如下
class EmployeeDAO
{
    IDBConenctionFactory* dbConnectionFactory;
    IDBCommandFactory* dbCommandFactory;
    IDataReaderFactory* dbReaderFactory;
public:
    vector<EmployeeDO> GetEmployees()
    {
        IDBConnection* connection = dbConnectionFactory->CreateDBConnection();
        connection->ConnectionString("...");

        IDBCommand* command = dbCommandFactory->CreateDBCommand();
        command->CommmandText = ("...");
        command->SetConnection(connection); // 关联性

        IDataReader* reader = command->ExecuteReader(); // 关联性
        while(reader->Read()) { }
    }
}
```

上述代码中，不难发现，IDBConnection和IDBCommand以及IDataReader均具有关联性，那么分开写三个工厂就不是很好的选择，改善办法就是把三个工厂类合并成一个，保证了关联性，不会出现SqlSever用到Oracle情况。代码如下：

```cpp
// 三个工厂合并成一个工厂纯虚基类
class IDBFactory
{
public:
    virtual IDBConnection* CreateDBConnection() = 0;
    virtual IDBCommand* CreateDBCommand() = 0;
    virtual IDataReader* CreateDataReader() = 0;
};

// 具体工厂类
class SqlDBFactory : public IDBFactory
{
public:
    virtual IDBConnection* CreateDBConnection() {}
    virtual IDBCommand* CreateDBCommand() {};
    virtual IDataReader* CreateDataReader() {};
};

// 使用
class EmployeeDAO
{
    IDBFactory* dbFactory;
public:
    vector<EmployeeDO> GetEmployees()
    {
        IDBConnection* connection = dbFactory->CreateDBConnection();
        connection->ConnectionString("...");

        IDBCommand* command = dbFactory->CreateDBCommand();
        command->CommmandText = ("...");
        command->SetConnection(connection); // 关联性

        IDataReader* reader = command->ExecuteReader(); // 关联性
        while(reader->Read()) { }
    }
}
```

## 要点总结

- 如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以
- “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或者作用的关系。不同系列的对象之间不能相互依赖
- Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动
