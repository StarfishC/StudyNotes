# 单件模式 Singleton

“对象性能模式”

- 面对对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理

- 典型模式
  - Singleton
  - Flyweight

## 动机

- 在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只有一个实例，才能确保他们的逻辑正确性、以及良好的效率
- 如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？
- 这应该是类设计者的责任，而不是使用者的责任

## 模式定义

保证一个类仅有一个实例，并提供一个该实例的全局访问点

<div align="center"><img src="./images/单件模式.png" alt="单件模式" height= width= /></div>

## 例子

```cpp
class Singleton
{
private:
    Singleton();
    Singleton(const Singleton& other);
public:
    static Singleton* getInstance();
    static Singleton* m_instance;
};

Singleton* Singleton::m_instance = nullptr;

// 线程非安全版本
Singleton* Singleton::getInstance()
{
    if (m_instance == nullptr)
    {
        m_instance = new Singleton();
    }
    return m_instance;
};

// 线程安全版本，但是锁的代价过高
Singleton* Singleton::getInstance()
{
    Lock lock;
    if (m_instance == nullptr)
    {
        m_instance = new Singleton();
    }
    return m_instance;
};
```

## 要点总结

- Singleton 模式中的实例构造器可以设置为protected以允许子类派生
- Singleton 模式一般不要支持拷贝函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背
- 如何实现多线程环境下安全的Singleton？注意对双检查索的正确实现
